# Networks
Computer Networks Class

Implementation of a Reliable File Transfer Service Using Go Back N (GBN)
Protocol Over the UDP Transport Service

Objective

The purpose of this assignment is to implement a reliable File Transfer Protocol (FTP) service using Go Back N (GBN) Protocol over the UDP transport service. You will write the reliable FTP client and server programs based on the (GBN) Protocol that will communicate over the College of Engineering LAN. You will also write a gremlin function that will simulate unreliable networks which will corrupt, lose, and delay packets. You will also learn other important functions in computer networks.

Overview

Again, you must implement the reliable FTP client and server programs using C or C++ and they must execute correctly in the COE tux Linus computers. You will also implement segmentation and re-assembly function, an error detection function and a gremlin function (that can corrupt, lose, and delay packets with a specified probability). The overview of these software components is show in Figure 1 below.

The reliable FTP client and server program must have the following features, including the Go Back N (GBN) Protocol to ensure that the packets are received reliably.

The FTP client initiates the communication by sending an FTP request to the FTP server at a specific IP address, using only the port numbers that are assigned to your group. You must implement the GET command of the FTP protocol, where the FTP client will send a FTP request to the FTP server to transfer a data file from the server to the client which will then store the file in its local file server. The FTP request message will be of the following form:
																		GET TestFile
																		
The file, TestFile, to be transferred is originally stored in the local secondary storage of the server host. After receiving the GET TestFile command from the client, the server first reads the file and puts them in a buffer and sends the content of the buffer to the FTP client. the test file is an ASCII file and must be at least 80 Kbytes in size.  Since the requested file may be large, the server application will use the segmentation function to partition the file into smaller segments that will fit into a packet of size allowable by the network. Each segment is then placed into a 256-bytes packet that is allowed by the network. The packet must contain a header that contains information for error detection and other protocol information. You may design your own header fields that are reasonable sizes.

The server will use the Go Back N protocol with positive/negative acknowledgement and retransmission (PAR). You must use the windows size, N=16. The sequence number must be modulo 32. After it sends 16 packets, it will wait for a positive or negative acknowledgement from the client before it sends the next window size of packets. The last packet will be padded with NULL character if the remaining data of the file is less than 256 byes. At the end of the file it transmits 1 byte (NULL character) that indicates the end of the file. It will then close the file.

The packets are then passed to the error detection function which, at the server process, will compute the checksum and place the checksum in the header. The packet is finally passed through the gremlim function being sent via the UDP socket to the FTP server. The Gremlin function may randomly cause errors in some packet, drop some packets and/or delay some packets, depending on the corrupt, loss, and delay probability. This will emulate errors and delays that may be generated by the networklinks and routers.

Add cout or printf statements in the client programs to print the sequence numbers, ACK/NAK (acknowledgement) and data to indicate that they are sending and receiving the packets correctly, i.e. print each packet (say, only the first 48 bytes of data) that it sends and receives.

the client will receive data of the test file in 256-byte packets, i.e. the client will receive each 256-byte packet in a loop and writes them into a local file sequentially. After it receives a packet and verifies that it is correct, it will send an acknowledgement. Each packet is processed by the error detection function that will detect possibility of error based on checksum. The packet is then processed by the segmentation and re-assembly function that re-assembles all the segments of the file form the packets received into the original file. When the client receives a 1-byte message with a NULL character, then it knows that the last packet has been received and it closes the file. The server then constructs FTP response messages by putting the status on the header lines. The header line will be of the following form:
								GET successfully completed
								
Add cout or printf statements in the server program to print the sequence numbers, ACK/NAK (acknowledgement) and data to indicate that it is receiving and sending the packets correctly, i.e. print each packet (say, only the first 48 bytes of data) that it receives and sends.

Go Back N (GBN) Protocol

You are to design and implement a Go Back N protocol where the window size is 16 and the sequence number is modulo 32. Your Go back N protol will deal with erros, loss, and delays in packets.

The Go Back N protocol follows the pipeline principle as follows. After the ender sends packet 0, the sender then sends 15 additional packets into the channel, otimistic that packet 0 will be received correctly and not require retransmission. If that turns out to be right, then the ACK for packet 0 will arrive while the sender is still busy sending packets into the channel. Handling of packet 0 will then be done while the handling of packet 1 and subsequent packet is already underway. Thus, go Back N pipelines the processing of packets before the completion of previous packet transmission to keep the channel busy.

In your Go Back N protocol, the receiver must handle packet errors, lost packets and delayed packets the following ways.

1. When the receiver receives a packet, it must use the coding method of your choice to check for checksum erros. The sender also uses the same coding method. If the packet is free of error and in the right order it sends back an ACK to the sender. The sequence number of the ACK should be the next packet number that the receiver is expection. For example, if it receives a packet 2, then it sends an ACK with sequence number 3.
2. When the receiver detects an error in a packet, it must send back a NAK to the sender. The sequence number should be the next packet that the receiver is expecting. For example, if the receiver has received packets up to and including packet 3 and it then receives a packet that contains an error, then it should send a NAK with sequence number 4. If the receiver detects an error in the packet it must print out in its output trace that the packet (with sequence number) has erros. The receiver will then drop the packet and not pass it to the function that reassembles the data stream.
3. When the receiver receives a packet out of order (possibly due to a lost packet), it must ignore the out-of-order packets and must send back an ACK for the last packet that it received correctly. The function that receives the packet must check if it contains the expected sequence number. When it receives an out-of-order packet, then it print the sequence number in the output trace and indicate if there are lost or delayed packets.

ACK and NAK are never lost or damaged.

For each of the three corresponding cases above, the sender must respond as follows:
	1. When the sender receives an ACK, it must advance it's window forward. For example after the sender with send window [0-15] transmits packets 0 to 15, it receives an ACK with sequence number 8. Then the sneder must advance its send window to [8-23] and sends the new packets 16-23.
	2. When the sender receives a NAK with sequence number 8, it will retransmit packets [8-23]. A NAK with sequence number 8 indicates that the receiver has not received packet 8 correctly and has rejected all subsequent packets.
	3. When the receiver does not send back either an ACK or NAK, then the sender will timeout on the earliest packet that has not been ACKed, e.g. packet 2 timeouts. It then retranmits all packets 2 to 17.

In your experiments, the following interesting interaction may occur. If the sender timeouts and is in the process of retransmitting a window size of packets and a new ACK arrives. A simpler implementation is to complete the retransmission of those packets first before servicing the receiving of the ACK. Although this implementation is simpler, it is inefficient because the incoming ACK may indicate that the receiver has received some of the packets that are being retransmitted. A more efficient implementation is to cause the incoming ACK to interrupt the retransmission and the sender can then avoid retransmitting those packets that are being ACKed. In this project, you may chosse either implementation.

Another important implemenation issue is how to set the timer for all of the 16 packets that have outstanding ACKs. You need to set the timeout to a value less that 20 millisends and based on the estimated round-trip time. Since there is only 1 timer in each computer, you need to implement the earliest timeout using the real timer and the remaining 15 timers implemented in software as follows. After first setting the timer for packet 0, and after transmitting packet 1, the GBN protocol should record the start time for packet 1 relative to that or packet 0. When the ACK for packet 0 is received, then the real timer is set for packet 1 timeout. This can be repeated for all subsequent packets.

If packet 0 times out, then all subsequent packet must be retansmitted. A new timeout for packet 0 is set and all the software timers may also be reset at that time.

When the sender receives a NAK with sequence number n, it must stop the timer and immediately retransmit packet n and all subsequent packets. It also erases all software timers and reset the timer for packet n and re-creates the software timers for all subsequent packets.

for each packet tranmitted, the timeout value must not be more than three times the round trip time. If you assume the round trip time to be typically about 5 millicsec, then the timeout value should not be more than 15 millicsec. You can set the timeout for the recvfrom function using the setsockopt function by setting the SO_RECVTIMEO() socket option (see pages 386-387 of Unix Network Programming by R. Stevens, et. al.). The timer alarm will interrupt the server process that is waiting to receive the acknowledgement. When the timer times out, the server must retransmit the previous packet that is sent.

When the simple file transfer application send a stream of input data to the GBN program, GBN will break the input data stream into data packets of 256 bytes. If the total length is not a multiple of 256 bytes pad the last packet with 0s.

Each packet should also have a 16-bit checksum attached to the header of the packet, using any coding scheme of your choice. The sender comoputes the checksum value and attached it to the packet. The same coding scheme must be used by the receiver to check the checksum value. 

The packet header should contain a sequence number, although your implementation can use a one-byte field in the packet structure.

Gremlin Function

You program must allow the probabilities of damaged, lost, and delayed packets to be input as arguments when the program is executed. For delayed packets, your program must also allow the user to input the delay timer in milliseconds. These parameters for packet damage, lost, and delay probabilities and the delay time are passed to your Gremlin function. You will implement a gremlin function to simulate four possible scenarios in the transmission line: (1) transmission error that cause packet corruption, (2) packet loss, and (3) packet delay and (4) correct delivery. Corrupted and packets and lost packets are processed as in Project 1. When the delayed packet probability and delay time are given, 3.g. 0.3 and 4 millisecond, then three out of ten packets will be delayed for 4 milliseconds before being transmitted.

Error Detection Function

Error detection is implementation as in Project 1.

Testing

Run the FTP client and FTP server programs with the GBN protocol for reliable data transfer. Other software such as the segmentation and re-assembly, error detection and gremlin functions must also function correctly. The FTP client and server programs must execute on different tux Linux computers. Capture the execution trace of the programs. IN Linux, use the script command to capture the trace of the execution of the FTP client and FTP server program. The trace must contain information when packets and ACK/NAK are sent or received, when packets are corrupted, and when packets are lost. Sequence numbers and other relevant information of the packets must be printed.

Print the content of the input file read by the server program and the output file received by the client program.

Submission

Submit your source codes and the script of the executions of the programs in Canvas on or before teh due date. You will also demon your programs to the T.A. to verify that your programs execute correctly.

%script (Name)
%client tux178.eng.auburn.edu
<SN><ACK>..
<PATH>..

%exit
